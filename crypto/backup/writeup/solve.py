from sage.all import *
from hashlib import sha256 as sha
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad

p = 29013534775118090203203070238554424327170453916749470956945774357716777725407
q = 14506767387559045101601535119277212163585226958374735478472887178858388862703
g1 = 28446556882366081365527182223708500235554299137822127658695033509424350370159
g2 = 26708569584937779881916492271329613997695606014591048117116203268250111757767
Y = 15361401450441890979571026848603938439685623523432760845300080796241435011444

m1 = "Hi! Can you store the encrypted flag for me for a second? I will need it later."
s1,s2,R1= (13205737753786145631452557588406232353600988478055542460813697878122967446578,13958963271047914149117054426506396333295463042827503250264570272717038726261,10975523781415982714076120021487634912523174941670197886572626886997379163321)

m2 = "Here's the flag: 2ccb051234f87b7786c829e31ed2539d62f93c39da366b5d8a74890960c1fc38d33b6fbd804fb5aa555e3e2928e1e06c564956eb2f320dde516ababeb71d525b9069538a7abc76cb3c94b7955654c041"
flag_enc = bytes.fromhex("2ccb051234f87b7786c829e31ed2539d62f93c39da366b5d8a74890960c1fc38d33b6fbd804fb5aa555e3e2928e1e06c564956eb2f320dde516ababeb71d525b9069538a7abc76cb3c94b7955654c041")
s3,s4,R2= (9179666933751539920348309886276181210967936400505991858211575258442611791125,9320577211559440207387497803168253329006224294550698569339457019099653730952,27255728356841764650107110242922607077260936240190827215432957010403469676198)


def hash(inputs):
    if not hasattr(inputs, "__iter__"):
        m = inputs
    else:
        m = "".join(map(str, inputs)).encode()
    return int(sha(m).hexdigest(), 16) % q

h1 = hash([m1, R1])
h2 = hash([m2, R2])

# (b' - a') + (s3 - s4) - (s1 - s2) * h2 / h1 - (b - a) * h2/ h1 = 0 mod q
# k1 = (b' - a')
# k2 = (b - a)
# t = - h2 / h1 mod q
# u = (s3 - s4) - (s1 - s2) * h2 / h1

t = (- h2 * inverse_mod(h1, q)) % q
u = ((s3 - s4) - (s1 - s2) * h2 * inverse_mod(h1, q)) % q

K = 2 ** 128

B = matrix(ZZ, [
    [q, 0, 0],
    [t, 1, 0],
    [u, 0, K]
])

shortest_vector = [row for row in B.BKZ() if K in row][0]
print(shortest_vector)

k1 = abs(shortest_vector[0])
k2 = abs(shortest_vector[1])

delta = ((s1 - s2 + k2) * inverse_mod(h1, q)) % q

print(delta)
print(k2)

key = hash([delta]).to_bytes(32, "big")
cipher = AES.new(key, AES.MODE_CBC, iv=flag_enc[:16])
pt = unpad(cipher.decrypt(flag_enc[16:]), 16)
print(pt.decode())
