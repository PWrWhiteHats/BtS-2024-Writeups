# Writeup

Three files are given:
- encrypted.bin
- message.txt
- OTPCrypt.java
- GeneratePad.java

File `encrypted.bin` contains message to decrypt.
File `message.txt` shows format of the encrypted message.
There are two Java programs: `OTPCrypt.java` and `GeneratePad.java`. 
The first one performs OTP encryption by XOR-ing input file with file "key.bin"
The second generates the pad (key) later used to encrypt the message and saves it in "key.bin" file.  
Key generation is done by using Random.nextBytes() function from java.util.Random, which, according to the Java documentation, uses Linear Congruential Pseudo-Random Generator (LCPRNG).

After it is seeded, it generates it's next state by a recurrence relation:

```
R(n+1) = (a*R(n) + c) mod m
R(0) = seed
```

The parameters "m" (referred as the modulus), "a" and "c" are known, predefined and carefully selected numbers,
R(n) is the state, which is a number less than m, seed is the initial state.
The generated output pseudo-random number is created from part of the state bits.

java.util.Random implements such generator with parameters:
```python
m = 2**48
a = 0x5DEECE66D = 25214903917
c = 0xB = 11
```

Function nextBytes() generates pseudo-number series of bytes, which is done by calling nextInt() and writing the result \
number as bytes in little-endian byte order.
The number returned by nextInt() function is made of the upper 32 bits of the state.
There are 2**48 possible states, which is quite a lot to bruteforce, but there is a faster solution.

## The attack

The encryption is done by XOR-ing the message with the key, therefore, as we know the beginning of the message,
we can get first bytes of the key by XOR-ing the ciphertext with known plaintext part. Out of first known bytes,
we can recover the numbers that have been generated by nextInt() during the key generation:

```python
import struct

key_part = bytes(k ^ e for k, e in zip(known_data, encrypted_data))
key_part = key_part[:(len(key_part)//4)*4]  # cutting to the number of bytes divisible by 4
known_numbers = []
for (number,) in struct.iter_unpack('<I', key_part):
    known_numbers.append(number)
```

As a random number is part of the state, we can recover 32 out of 48 state bits:
```python
upper_part = known_numbers[0] << 16
```
The remaining 16 bits can be easily bruteforced by checking if the next number generated by the generator matches
known key part. The seed is the initial state, so it can be recovered by reversing the previously mentioned relation:
```
R(n+1) = (a*R(n) + c) mod m
R(n) = (R(n+1) - c) * a**(-1) mod m
```

where a**(-1) is the multiplicative inverse of "a" modulo "m", that can be computed by using Extend Euclidean algorithm,
or the `pow(a, -1, m)` Python function.

```python
for possible_lower_part in range(0, 2**16):
    possible_state = upper_part + possible_lower_part
    if get_rand(next_state(possible_state)) == known_numbers[1]:
        primary_seed = previous_state(possible_state)
```

Recovered seed can be used to recreate the whole encryption key, but it's important to know that setSeed(seed) function
performs XOR operation before setting the actual state:
```java
state = (seed ^ 0x5DEECE66DL) & ((1L << 48) - 1)
```

Thus, to recover the actual seed that can be used with setSeed() function to recreate the encryption we need to XOR again:
```java
primary_java_seed = primary_seed ^ 0x5DEECE66D
```

Computed Java seed can now be used to recover whole encryption key, for example by a little modification of GeneratePad.java program:
```java
long seed = 198371326437647L;
Random rand = new Random(seed);
```

In the end, the modified program yields recovered "key.bin" file, which can be used with OTPCrypt program to decrypt the message:
```commandline
java GeneratePad 100  # at least the length of the message
java OTPCrypt encrypted.bin message.txt
```

Finally, the recovered message is:
```
The flag is BtSCTF{M4yb3_LCG_i5_n0t_so_raNdom_841f3b4}
```

## Final solution code

The whole seed recovering program:
```python
import struct


class JavaCracker:
    a = 0x5DEECE66D
    c = 11
    m = 2 ** 48

    def next_state(self, state):
        return (state * self.a + self.c) % self.m

    def previous_state(self, state):
        s = (state - self.c) % self.m
        return s * pow(self.a, -1, self.m) % self.m

    def check_next_valid(self, possible_state, number):
        if self.get_rand(self.next_state(possible_state)) == number:
            print('Possible primary seed: {}, next number: {}'.format(
                self.previous_state(possible_state),
                self.get_rand(self.next_state(self.next_state(possible_state)))))

    def get_rand(self, state):
        return state >> 16

    def crack(self, known_numbers: tuple):
        upper_part = known_numbers[0] << 16
        for possible_lower_part in range(0, 2**16):
            possible_state = upper_part + possible_lower_part
            if self.get_rand(self.next_state(possible_state)) == known_numbers[1]:
                primary_seed = self.previous_state(possible_state)
                primary_java_seed = primary_seed ^ 0x5DEECE66D
                print('Possible primary seed: {} (java setSeed value {}), next number: {}'.format(
                    primary_seed, primary_java_seed,
                    self.get_rand(self.next_state(self.next_state(possible_state)))))


known_data = b'The flag is'  # at least 8 bytes

with open('encrypted.bin', 'rb') as f:
    encrypted_data = f.read()
    key_part = bytes(k ^ e for k, e in zip(known_data, encrypted_data))
    key_part = key_part[:(len(key_part)//4)*4]
    known_numbers = []
    for (number,) in struct.iter_unpack('<I', key_part):
        known_numbers.append(number)
    print('Known number list:', known_numbers)
    cracker = JavaCracker()
    cracker.crack(known_numbers)

```

Modified GeneratePad.java:
```java
import java.io.*;
import java.util.Random;
import java.nio.file.Files;
import java.nio.file.Paths;

public class GeneratePad {
    public static void main(String args[]) throws NumberFormatException, IOException {
        if (args.length != 1) {
            System.out.println("Usage: <size of key in bytes>");
            System.exit(1);
        }
        int size = Integer.parseInt(args[0]);
        long seed = 198371326437647L;
        Random rand = new Random(seed);
        byte[] randBytes = new byte[size];
        rand.nextBytes(randBytes);
        Files.write(Paths.get("key_cracked.bin"), randBytes);
    }
}

```
